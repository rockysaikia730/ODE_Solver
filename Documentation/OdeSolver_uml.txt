{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 class OdeSolver \
     public pure virtual DynamicTensor ComputeStep();\
     public virtual void Step();\
     public void SetTimeSpan(int);\
     public void SetTimeSpan(double);\
     public const DynamicTensor& GetSolution() const;\
     public double GetStartTime() const;\
     public double GetEndTime() const;\
     public double GetStepSize() const;\
     public int GetNumberOfSteps() const;\
     public virtual void Reset();\
     public void Solve();\
     public OdeSolver(const Ode& ode, int num_of_steps, double end_time);\
     public OdeSolver(const Ode& ode, double, double);\
      protected const Ode& ode_;\
      protected double start_time_;\
      protected double end_time_;\
      protected  double step_size_;\
      protected DynamicTensor solution_;\
      protected double current_time_;\
\
class MultiStepOdeSolver(OdeSolver)\
    public MultiStepOdeSolver(const Ode& ode, double step_size = 0.01, double end_time = 0.0, int order_solution = 1, int order_derivative = 1);\
    public MultiStepOdeSolver(const Ode& ode, int num_of_steps, double end_time = 0.0,int order_solution = 1, int order_derivative = 1);\
    protected virtual void InitBuffers();\
    protected void UpdateDerivative(const DynamicTensor& dydt);\
    protected void UpdateSolution(const DynamicTensor& y);\
    protected void UpdateWindowSum();\
    public void Reset() override;\
    public void Step() override;\
    public pure virtual const std::vector<double>& GetCoeffsY() const;\
    public pure virtual const std::vector<double>& GetCoeffsdY() const;\
    protected int order_sol_;\
    protected int order_derivative_;\
    protected std::deque<DynamicTensor> solutions_buffer_;\
    protected std::deque<DynamicTensor> derivative_buffer_;\
    protected DynamicTensor sum_tn_;\
\
class RungeKutta(OdeSolver) \
    public RungeKutta(const Ode& ode, double step_size = 0.01, double end_time = 0.0);\
    public RungeKutta(const Ode& ode, int num_of_steps, double end_time);\
    public DynamicTensor ComputeStep() override;\
\
class AdamsBashforth(MultiStepOdeSolver)\
    public AdamsBashforth(const Ode& ode, double step_size = 0.01, double end_time = 0.0,  int order = 4);\
    public AdamsBashforth(const Ode& ode, int num_of_steps, double end_time = 0.0, int order = 4);\
    public DynamicTensor ComputeStep() override;\
    public const std::vector<double>& GetCoeffsY() const override;\
    public const std::vector<double>& GetCoeffsdY() const override;\
    public int GetOrder() const;\
    private int order_;\
\
class ImplicitSolver(MultiStepOdeSolver)\
    public ImplicitSolver(const Ode& ode, double step_size = 0.01, double end_time = 0.0, int order_solution = 1, int order_derivative = 0, std::shared_ptr<RootFinder> root_finder =nullptr);\
    public ImplicitSolver(const Ode& ode, int num_of_steps, double end_time = 0.0, int order_solution = 1, int order_derivative = 0, std::shared_ptr<RootFinder> root_finder = nullptr);\
    public virtual const std::vector<double>& GetCoeffsY() const = 0;\
    public virtual const std::vector<double>& GetCoeffsdY() const = 0;\
    public virtual DynamicTensor ComputeStep() override;\
    protected std::shared_ptr<RootFinder> root_finder_;\
    protected class ImplicitEquation(Function) public ImplicitEquation(const ImplicitSolver& solver);public DynamicTensor Eval(double t, const DynamicTensor& y_guess) const override;\
\
class AdamMulton(ImplicitSolver)\
    public AdamMoulton(const Ode& ode, double step_size = 0.01, double end_time = 0.0, int order = 2, std::shared_ptr<RootFinder> root_finder = nullptr);\
    public AdamMoulton(const Ode& ode, int num_of_steps, double end_time = 0.0, int order = 2, std::shared_ptr<RootFinder> root_finder = nullptr);\
    public const std::vector<double>& GetCoeffsY() const override;\
    public const std::vector<double>& GetCoeffsdY() const override;\
    public int GetOrder();\
    private int order_;\
\
class Bdf(ImplicitSolver) \
    public Bdf(const Ode& ode, double step_size = 0.01, double end_time = 0.0, int order = 4, std::shared_ptr<RootFinder> root_finder = nullptr);\
    public Bdf(const Ode& ode, int num_of_steps, double end_time = 0.0, int order = 4, std::shared_ptr<RootFinder> root_finder = nullptr);\
    public int GetOrder();\
    public const std::vector<double>& GetCoeffsY() const override;\
    public const std::vector<double>& GetCoeffsdY() const override;\
    private int order_;\
\
class BackwardEuler(Bdf) \
 public BackwardEuler(const Ode& ode, double step_size = 0.01, double end_time = 0.0, std::shared_ptr<RootFinder> root_finder = nullptr);\
 public BackwardEuler(const Ode& ode, int num_of_steps, double end_time = 0.0, std::shared_ptr<RootFinder> root_finder = nullptr);\
\
class ForwardEulerLight(OdeSolver)\
    public ForwardEuler(const Ode& ode, double step_size, double end_time, );\
    public ForwardEuler(const Ode& ode, int num_of_steps, double end_time);\
    public DynamicTensor ComputeStep() override;\
\
class ForwardEuler(AdamsBashforth)\
    public ForwardEuler(const Ode& ode, double step_size, double end_time, );\
    public ForwardEuler(const Ode& ode, int num_of_steps, double end_time);}